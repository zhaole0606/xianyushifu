
> [!info] 
> 王爽《汇编语言 第四版》学习笔记\
> **基于8086系统**

### 基础知识
CPU跟内存打交道，从内存中读指令和数据，磁盘跟内存打交道，磁盘加载到内存中。 
>[!tip]
>指令和数据都是应用上的概念，在内存和磁盘上都是二进制数据没有任何区别。一串二进制既可以表示数据也可以表示是指令。计算机区分一串二进制是指令还是数据，就看这串二进制数据从哪条总线走。
>

CPU主要是跟内存打交道进行读写操作。
	 1. 获取内存的地址（地址信息）。
	 2. 当前CPU操作是读还是写（控制信息）。
	 3. 具体读或写的内容信息（数据信息）。
  CPU不可能凭空跟内存进行上面的三步交互的。计算机处理和传输信息都是电信号，电信号又是通过导线传输。CPU通过多根导线将三种信息传入到存储器的芯片中，在逻辑上根据传递信息的不同划分出**地址总线，控制总线，数据总线**。
 一个CPU的地址总线宽度为10，那它的寻址范围是就0-$2^{10}$,它的内存空间大小就是$2^{10}$，**这不是内存的最大空间而是它能被CPU寻址的最大范围**。
  控制总线，数据总线，地址总线是让CPU和主板上其他外部设备进行联系，而CPU内部运算器，控制器，寄存器是通过CPU的内部总线进行联系。
### 寄存器(CPU工作原理)
8086CPU有14个寄存器，**AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW**。在后面的学习中逐渐展开学习。
#### 通用寄存器
AX、BX、CX、DX 四个奇存器通常用来存放一般性的数据,被称为通用寄存器。
通用寄存器是**16位  = 2个字节=1个字**。一个寄存器可以分成两个8位寄存器，分别是高8位(8-15)和低8位(0-7)。
一个寄存器的低位进行进位计算，产生的进位并不会存在到更高位的寄存器中，CPU会有个专门的寄存器来存储这个进位。
#### 物理地址
8086有**20位地址总线**，能达到$2^{20}=1M$的寻址空间，CPU只有**16位**表现的寻址能力也就$2^{16}=64KB$。所以采用两个16位地址来来合成一个20位地址。
2个16位地址一个称为段地址SA，一个称为偏移地址EA经过**地址加法器**变成20位地址。地址加法器合成地址方法：**物理地址=段地址 x 16 + 偏移地址**  
>[!tip]
>我们是以十六进制展示地址，所以乘以16就相当于十进制乘以10， 二进制乘以2，增加十倍。从二进制来看乘以16就是乘以$2^4$，也就是二进制模式下左移4位。\
> 8086CPU设计如此，由于CPU只有16位，但是配备了20位的地址总线，为了能在16位CPU下实现20位的地址寻址

偏移地址16位，变化范围为 O~FFFFH，仅用偏移地址来寻址最多可寻64 KB 个内存单元。再给出定段地址，如1000H，用偏移地址寻址，则CPU 的寻址范围为：10000H~IFFFFH。
#### 段寄存器
物理地址根据段地址和偏移地址组合而来，在CPU中就要有存储段地址和偏移地址的地方，首先就是存段地址，8086CPU有4个段寄存器**CS,DS,SS,ES**，分别对应代码地址，数据地址，堆栈地址，额外地址寄存器。
#### CS段寄存器
**CS**是代码段寄存器，**IP**是指令指针寄存器，CS:IP是非常重要的寄存器，它们两个合并**指示了CPU当前要读取指令的地址**

### 寄存器(内存访问)

>[!tip]
![[Pasted image 20240222192737.png]] \
16位寄存器存储一个**字**，如AX，高8位AH存高字节，其中低8位AL存低字节。
内存单元是按照**字节**存储，所以一个字占用两个连续的内存单元。高字节存储在高地址单元，低字节存储在低地址单元。
如上图所示，内存从上到下地址单位递增。所以正确展示是4E20H，其中值得注意的是此时IP指向的是0，如果读取0012H则IP移动到2这个位置。

#### DS段寄存器
 CPU读写内存单元是需要先给出这个内存单元的地址，因为地址是段地址和偏移地址组合而来，所以首先需要一个段寄存器来存储段地址，8086CPU中用**DS**寄存器来存放需要访问数据的段地址。
CPU在执行的时候自动读取DS中的数据为内存单元的段地址，紧接着用[x]表示内存中便宜的位置，x为具体偏移地址位，
```assembly
;将10000H(100:0)中的数据读到al中
mov bx,1000H
mov ds,bx
mov al,[0]
```
 **8086CPU不支持数据直接存入段寄存器，需要通过一个通用寄存器中转一下**。
#### SS栈段寄存器
CPU将一段连续的内存作为栈空间，它也是通过段寄存器来知道具体的位置。段寄存器**SS**和**SP**。栈顶的段地址存放在SS中，偏移地址存放在SP中。**任何时刻SS:SP指向栈顶元素**。**栈操作一定是先移动SP指针，再入/出栈。** push和pop默认访问的是**字单元**。
栈的特点就是先进后出，在汇编语言中表现如下
```assembly
;这个例子实现了简单数据交换
push ax ;ax压栈
push bx ;bx压栈
pop ax  ;从栈中弹出栈顶元素，并赋值给ax
pop bx  ;从栈中弹出栈顶元素，并赋值给bx
```
栈中数据出栈不是真的从栈中删除，而是栈顶指针变了，数据其实仍然在栈中。
>[!tip]
栈中没有元素的时候，SP是指向哪的？\
当栈中只有一个元素的时候，SS:SP指向栈顶，当没栈中没有元素的时候，SP+2指向栈顶以下。\
例如，栈顶底部字单元的地址是1000:000E，栈空的时候SP=0010H

### 编写汇编程序
汇编源程序中，数据不能以字母开头，如果最后一位是字母需要在前面加个0。例如，A000h要写为0A000h。

### \[bx\]和loop指令
#### \[bx\]
前面介绍了段地址SA默认在**DS**中，后面跟的偏移地址则放在**bx**寄存器中与**DS**配合使用SA:EA。
>[!tip]
8086中Debug和汇编编译器在**将内存中数据送入寄存器**处理上有所不同。对于编译器来说，这条 mov ax,[0] 指令，中括号中是数字，则中括号识别不了，也就是说原本从内存中写入到寄存器中的指令被认为是mov ax,0 直接将数值写入寄存器。设计如此不必纠结。所以有下面两种表现方式
```assembly
mov ax,2000h   
mov ds,ax,
mov bx,6
mov ax,[bx]
;或者
mov ax,2000h
mov ds,ax
mov ax,ds:[6]
```

mov ax,[0] 表示将ds:0处的数据送入al中，读取内存单元的数据到寄存器中，值得注意的是**内存是字节型为8位，寄存器则是16位，从内存中读取一个字节只能放在一个字的寄存器的低位里面**。
#### loop
loop循环指令配合cx寄存器使用。cx寄存器存储的循环次数，每调用一个loop，cx寄存器中的值减一。
### 包含多个段的程序
将数据，代码，栈放如不同的段，这样显得更加清晰。
```assembly
assume cs:codeseg，ss:stackseg,ds:dataseg
stackseg segment
	...数据...
stackseg ends
dataseg segment
	...数据...
dataseg ends
codeseg segment
start:
	...代码...
codeseg ends
end start
```
上述代码中包含了汇编指令和伪指令，汇编指令有对应的机器码，伪指令则是给编译器来执行的。
start是告诉编译器程序入口在什么地方。**也就是CS:IP指向的地方**。
dw指令是定义字形数据，还有dd，db代表定义双字数据，定义字节数据。例如，dw 0123h,0456h,0789h,0abch。定义4字型数据，它们所占内存空间为8字节。
>[!tip]
如果没有`end start` 这类关键词定位到代码执行部分，等到编译后CS:IP指针指定的位置是dw的初始位置，而不是代码执行的位置。如果加上start关键字后，CS:IP指向指令代码，DS+10h的位置则指向初始数据，DS段偏移10H则是PSP区。
### 灵活的定位内存地址
#### and和or指令
and 和or指令是做逻辑运算，尤其是在大小写转换。
and的特点同为1，异为0。
or特点只要有一位是1都为1。
>[!tip]
大小写字母对应ASCII码再转成二进制都有个特点，二进制从右往左第五位大写字母为0，小写字母为1。其他位都相同\
A   01**0**0,0001   ，  a   01**1**0,0001\
大小写转换就是改变这个位置的值，这时候and和or就起作用了。\
 `or 0010,0000` 变成小写\
`and 1101,1111`变为大写。

#### SI和DI寄存器
 si和di功能与bx类似，但是不能分成2个8位寄存器。

### 数据处理的两个基本问题

#### 指令要处理的数据有多长
8086CPU能处理两种尺寸的数据，byte和word，在机器指令中对于那些不明确长度的指令要指明。
何为明确长度的指令，下面几条由寄存器指明了指令进行的是字/字节操作。
```assembly
mov ax,1
mov bx,ds:[0]
mov al,ds:[0]
```
没有寄存器的情况下，就需要加**word/byte ptr**  显式指明内存单元的长度。
```assembly
mov word ptr ds:[0],1
mov word ptr ds:[0]
mov byte ptr ds:[0],1
```
#### div 指令
 对于div除法，被除数的宽度一般是除数的2倍。
* **除数**：8，16位两种。
* **被除数**：放在ax（16位被除数）和dx，ax（32位被除数，`dx`存放高16位，`ax`存放低16位）中。
* **结果**：除数8位，al存商，ah存余数。除数16位，ax存商，dx存余数
#### dup
dup操作符是搭配dd,dw,db这些伪指令使用的，由编译器识别处理。作用是进行数据重复。
db 3 dup (0)，定义了3个字节，值为0。相当于db 0,0,0 
db 3 dup (1,2) ,定义6个字节，相当于 db 1,2,1,2,1,2
### 转移指令的原理
可以修改IP和CS,IP的指令统称为转移指令。
根据转移指令对IP修改的范围不同，段内转移分为，段内短转移和段内近转移。分别对应的IP范围是-128~127和-32768~32767，单位字节。
8086CPU的转移指令有**无条件转移，有条件转移，循环指令，过程，中断**
#### offset操作符
offset操作符的作用是获取标号的偏移地址。如下面的例子。
```assembly
assume cs:codesg 
codesg segment 
	start:mov ax, offset start  ;相当于mov ax,0
	    s:mov ax,offset s       ;相当于mov ax,3
codesg ends 
end start  
```
#### jmp指令
无条件跳转指令，可以修改IP或CS和IP
**段内短转移** jmp short 标号 8位偏移。
**段内近转移** jmp near ptr 标号 16位偏移。
>[!tip]
>**jmp做段内转移的时候，全部使用的是相对位置**。如下图所示:
>1. 当CS:IP读取`jmp 40`指令到指令缓冲器后，IP自增读取指令的长度。也就是IP+2指向0003。
>2. CPU执行指令缓冲器中的指令EB03，IP+机器码 = 0003+0003 = 0006，也就是s0位置\
>3. 继续执行到0007又遇到jmp，如上面流程指令读入指令缓冲器后，IP增加2\
>4. 由于**偏移量是有符号**范围在-128-127。F7算补码，负数用补码计算,F7的补码是9。0009-0009= 0000 就调回s处。\
>
>**备注**：如果不清楚补码如何计算请参考[[01.基础-原码，反码，补码]]
>
```assembly
偏移地址     机器码        汇编指令
 0000        40         s:inc ax
 0001        EB03         jmp s0
 0003        BB0300       mov bx,3
 0006        43        s0:inc bx
 0007        EBF7         jmp s
 0009        90           nop
```
 
 `jmp far ptr 标号`段间转移(远转移)，jmp则是直接给出CS:IP的具体值，没法用相对位置了。唯一需要注意的就是指令存储的顺序。
```assembly
;010B 低地址
;0BBD 高地址
OBBD:0006 EA0B01 BD0B  JMP 0BBD:010B
```
`jmp 16位reg`寄存器转移。
#### JCXZ指令
 jcxz （Jump if CX Zero）**会去检查cx寄存器**，如果cx不等于0什么也不做向下执行，如果等于0则跳转。
 
### CALL和RET指令
call和ret都是转移指令，都修改IP或者修改CS和IP。
#### ret和retf指令
ret指令用栈中数据修改IP，实现进转移。
```assembly
;相当于
pop IP 
```
retf指令用栈中数据修改CS和IP，实现远转移。
```assembly
;相当于
pop ip 
pop cs
```
#### call指令
 **对于段内转移**call指令将下一条指令(当前IP或者CS和IP)压栈，并用下一条指令的内存地址+标号地址=跳转的目的地（也就是jmp指令的运用）。
```assembly
push ip
jmp near ptr
```
用一个例子表示。其中计算
```assembly
汇编               地址     机器码
;此处的s只是汇编语言写的目的地，
;CPU肯定不是根据s跳转到相应的位置。
call s        1001:000B  E8 05 00 						  
;call调用时候，将000E（此处为IP实际指向位置）入栈。					
;call后面的标号也就是机器码中地址0005加上000E(IP地址)=0013H ，
;这个就是需要jmp的目标IP地址。
mov ax,4c00h  1001:000E  E8 00 4c 								
...
s:add ax,ax    1001:0013  03 c0
 ret           1001:0015  c3
```
对于段间转移是`call far ptr 标号`。相当于
```assembly
push cs
push ip
jmp far ptr 标号
```
基于寄存器的call，`call reg`,相当于
```assembly
push IP
jmp 16位寄存器
```

#### mul指令
**乘数**：同位相乘8位或者16位相乘，如果是8位，默认放在AH，如果是16位一个某认在AX中，另外一个放在16位寄存器或者内存字单元。
**结果**：8位乘法，结果放在AX中。16位乘法高位默认在DX，低位在AX中。

### 标志寄存器
标志寄存器flag有16位。它的每一位都是存储一种状态数据。存储的信息称为**程序状态字PSW**。所以它的每一位都有专门的含义。8086CPU用到标志寄存器中的**9**位。
**ZF标志**，零标志位。结果为0 ，ZF=1，结果不为0，ZF=0。这个寄存器用来。
**PF标志**，奇偶标志位。偶数，PF=1，奇数，PF=0。此处的奇偶判断是指二进制中1的数量。
 **SF标志**，符号标志位，记录相关指令执行后的结果。结果为负，SF=1，结果非负，SF=0
 **CF标志**，进位标志，有进位，CF=1，无进位，CF=0，**无符号**数运算时候记录进位（有进位就记录）。
 **OF标志**，针对**有符号**运算超出机器表达的范围。溢出，OF=1，没有溢出，OF=0。
#### adc 指令
进位加法指令，利用了CF位上记录的进位值。
**add  对象1，对象2  =>  对象1 = 对象1 + 对象2 +CF**
加法运算不是一步到位的，是低位跟低位，高位跟高位。会出现低位相加有进位的。等到高位相加的时候用adc计算就会带上CF进位。
计算：1EF000H+201000H，结果放在ax（低高6位）和bx（低16位）
```assembly
mov ax,001EH
mov bx,0F000H
add bx,1000H
adc ax,0020H
```
#### sbb指令
带借位减法指令，利用CF位上记录的借位值
**sbb  对象1，对象2  =>  对象1 = 对象1 - 对象2 -CF**
#### cmp指令
比较指令，相当于减法指令，只不过不保存结果，只会对标志寄存器产生影响。其他指令通过识别被影响的标志寄存器位来得知比较结果。
#### DF标志和串传送指令
方向标志位，在串处理指令中，控制每次操作后si，di的增减。df=0 每次操作后si，di递增。df=1 每次操作后si，di递减。
传送指令movsb，将ds:si指向的内存单元中的字节送入es:di中，然后根据df位的值将si和di递增或递减1
movsb指令里面的b是字节的意思，如果传送一个字就是movsw，si,di就会递增或递减2。
movsb,movsw串传送指令一般配合rep指令。重复执行串传送指令然后si和di递增或递减。类似loop。
df位决定了si和di的方向，所以CPU也提供了相应的指令来对df位进行设置。
cld指令：将标志寄存器的df位置0。
std指令：将标志寄存器的df位置1。
#### pushf和popf
pushf指令的功能是将标志寄存器值压栈，popf的从栈中弹出数据，送入标志寄存器中。
### 内中断
CPU在执行完当前正在执行的指令之后，检测到从CPU外部发送或内部产生的一种特殊信息，CPU可以立刻对所接受到信息进行处理，这种特殊的信息称为**中断信息**。
CPU内部有四种情况可以产生需要及时处理的中断信息。CPU首先要知道接收到中断信息的来源，所以中断信息包含识别来源的编码。这种**中断类型码**用一个字节表示就可以了，能表示256中中断信息来源。

#### 中断程序
CPU收到中断信息就需要对信息进行处理，而如何处理则是由编程决定的，一般来说需要对不同的中断信息编写不同的**中断处理程序**。**中断向量表是用于处理硬件中断的数据结构。**
CPU知道中断信息中的中断类型码就知道该执行哪个中断程序了。若要定位到程序则还需要知道程序的段地址和偏移地址。CPU是通过内存中的**中断向量表**让中断类型码和中断程序的入口地址关联上。
**8086PC机上中断关联表存放在内存地址0处，从0000:0000到0000:03E8一共1000个单元。**
中断向量表中，存储的是段地址和偏移地址，所以一个表项是2个字，4个字节。
#### 中断过程
通过中断类型码在中断向量表中找到对应的中断处理程序入口，找到这个入口就可以设置CS:IP。CPU就可以执行中断处理程序。整个操作流程是**计算机硬件**自动完成。这个操作流程就是**中断过程**。
CPU在执行完中断程序后需要返回到原来的执行点继续执行后面的命令，所以在CPU进入中断过程前要保存当前CS和IP的值。然后再设置中断程序的CS:IP。
8086CPU在收到中断信息后引发中断过程如下：
1. **取得中断类型码N**
2. **pushf**
	 将标志寄存器值入栈，因为中断过程中会改变标志寄存器的值
3. **TF=0,IF=0**
	先介绍TF标志寄存器，TF=1时，CPU会在执行每条指令后产生一次中断，称为单步中断。单步中断的作用是让程序以单条指令为单位执行，这对于调试程序很有帮助。
	上面提到中断向量表中记录各种中断类型码对应的中断程序入口地址。所以单步中断的类型码也在其中就是1，**(IP)=(1\*4),(IP)=(1\*4+2)** 就是它的程序地址入口。
	至于为什们要置为0那是因为中断处理程序也是一条条指令组成。如果执行中断程序之前TF=1，那CPU在执行完中断处理程序的第一条指令后，要产生单步中断。就会去执行单步中断的中断处理程序，在执行完中断处理程序的第一条指令后又会产生中断。又要去执行单步中断程序的中断处理程序...直接陷入死循环。所以在进入中断处理程序前设置TF=0避免这个问题。
	在介绍下IF标志寄存器，除了CPU的内部中断，还有来自外部的中断信息。所以再进入中断处理程序后，需要禁止其他的可屏蔽中断。（具体见后面）
1. **push CS**
	将当前CS值入栈
 5. **push IP**
	将当前IP值入栈
 6. **设置中断程序的入口**
	上面说了中断程序从内存0000:0000开始，并且每项长度是2个字。所以有下面的公式
	  (IP)=(N\*4),(CS)=(N\*4+2)  获取中断程序的入口后设置CS:IP。
 7. **恢复现场**
	处理完中断程序后CPU需要跳回原来的执行点。调用的是**iret**指令，这个指令相当于
	```assembly
	pop IP
	pop CS
	popf
	```
	先弹出保存的IP,CS再弹出保存的标志寄存器。
### int指令
int n ，n为中断码，功能就是引发中断。类似于call指令，CPU 执行int n的时候会引发中断过程，执行n对应的中断处理程序。
### 端口
和CPU通过总线相连的一些芯片(存储器，接口卡，外设等等)里面都有一组可以有CPU读写的寄存器。首先它们都跟CPU总线相连，其次CPU对它们进行读写时候都通过控制线向它们所在的芯片发出端口读写命令。
从CPU角度来说这些寄存器都当做端口，对他们进行统一编址，每一个端口在地址空间中都有一个地址。
CPU可以直接读写数据的地方有三个，**CPU内部寄存器，内存单元，端口**。
上面提到每个端口都有自己的地址，CPU在读取的时候就是访问这些地址，通过in和out从端口读/写数据。
in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口的数据。
#### shl和shr指令
这两个都是位移指令，一个是左移一个是右移
它的功能:
1. 将一个寄存器活内存单元中的数据向左/右移动
2. 将最后移出的一位写入CF位
3. 最低位补0

将X逻辑左移一位 相当于X=X\*2
将X逻辑右移一位 相当于X=X/2

如果移动位数大于1，必须将移动位数放在cl上

### 外中断
外中断来自于IO，对外设进行控制。PC系统的接口卡和主板上有各种芯片，外设接口芯片内部有若干寄存器，CPU将这些寄存器当做端口来访问。
外设的输入不是直接送入内存和CPU，输出也不是直接送入外设，而是送入相关接口芯片的端口，再由相关芯片根据命令对外设进行操作。

之前说的内中断是CPU内部产生中断类型码，而外中断的中断类型码是通过总线送入CPU中

外中断源一般有两类
1. 可屏蔽中断
	它是CPU可以不响应的外中断，它是通过IF寄存器设置。当CPU检测到可屏蔽中断信息，如果IF=1则CPU执行完当前指令后会响应中断
	它的处理中断的流程与内中断类似。除了第一步的中断码来自于外部。
2. 不可屏蔽中断
	顾名思义就是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息，在执行完当前指令后立刻响应引发中断过程。
	**中断类型码固定为2。**

